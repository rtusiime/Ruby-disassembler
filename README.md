# Ruby-Disassemberüíé

## Description

In this project, I implemented an online source code and assembly cross-referencing tool. We used ruby to compile a C program, generate it‚Äôs DWARF information and assembly code, and generate the required HTML, CSS and JavaScript code to render this information in a web page. The web page is also interactive. It highlights lines of assembly or source code when a user clicks their corresponding source code or assembly lines, respectively.

## Files

**Description:**

1. **disassem.rb**: Contains the ruby code to generate the Objdump, DWARF file of the provided c program.
2. **ascii.c**: C program provided by Professor Scott.
3. **header.txt:** HTML, Javascript and HTML code to render the webpage.
4. **priority_queue.c:**  Extra C program to be used as test case.
5. **LinkedList.c:** Extra C program to be used as test case.

**How to run program**

- Compile the program using gcc

```markdown
gcc -g3 -O1 -o <object_file_name> <source_file_name> //**NOTE:** the resulting HTML files will be named after the object file
```

- run the following command in the terminal

```markdown
ruby disassem.rb <object_file_name> <source_file_name>
```

- Several files will be autogenerated. The webpage is contained in `object_file_disassem.html`.

## General Approach

Our ruby program runs shell commands to compile the provided C program and then generate the Objdump and DWARF dump of the compiled program. 

We then create four hashmaps:

```markdown
**sline2add** - Maps a line in the source code to a **LIST** of assembly address
**add2sline** - Maps an assembly address to a **LIST** of source code lines
**aline2add** - Maps an assembly line to **ONE** assembly address
**add2aline** - Maps an assembly address to ONE assembly line
```

We use regular expressions to parse the Objdump and DWARFdump file. We use the table at the bottom of the DWARFDUMP to map each source code line to its corresponding assembly address.
Since the DWARFDump omits some assembly lines, we fill them in based on the OBJDump.

We display our HTML, Javascript and CSS code in one contiguous string block using a nifty ruby feature known as `heredoc`

**A few issues that weren‚Äôt initially obvious:**

1. Parsing the addresses and storing them in a hashmap required us to convert it from `string` to `hex` number using `to_i(base=16)` and then to a decimal number. Then whenever we want to display it/print it, we convert it back to a hexadecimal number.
2. While parsing the source code, we also have to count the blank lines (initially we didn‚Äôt, which had the unintended consequences of mismatching the line‚Üíaddress mapping in the DWARFDump table.
3. We had to find a way to parse from the OBJDump just the assembly code we needed. We noticed that the start address displayed in the example solution corresponds to the first address in the DWARFDump table, and the last address corresponds does not quite correspond to the last address in the table but is quite close. ‚Äî‚Äî‚Üí //to do‚Üí update this with explanation of what we did.
4. We realised that there are three main cases when pattern matching the objdump from the start address and end sequence: 
    1. Hex number and function name ( for example `00000000004011bf <main>:` ) ‚Üí In this case, we print it to the HTML file and convert `<` and `>` to their HTML equivalent.
    2. If it‚Äôs an empty line, we just print it.
    3. Hex number and address (for example `4011ab:	bf 10 20 40 00`) ‚Üí In this case, we split the line. The first part will be the address, which we render as button text, and the second part will be the code, which we will put in a span. We will also check if address is the end the end address, if so, we will end the parsing. 
5. Contrary to what is mentioned on the assignment page, after extensive testing with other programs, we found that life the lines in the table are actually NOT sorted by assembly code address, to which we changed our code such that the start address is the minimum address in the table, and the end address is the maximum address (initially, we had set the start address to the first address in the table and the end address to the last address in the table).

## Testing

We run our program on various C programs of different complexities and even compile our programs with `gcc -g3 -O1 -o ascii ascii.c` to see if the output remains consistent.

Disclaimer for testing c programs: we obtained sample C programs, ‚Äòpriority_queue.c‚Äô and ‚Äòlinked_list.c‚Äô from the github repo ‚Äú[https://github.com/gouravthakur39/beginners-C-program-examples](https://github.com/gouravthakur39/beginners-C-program-examples)‚Äù. These are solely for testing the html generating functionality and correctness. 

We also test our program to different compiling optimization from `-O0` to `-O3`, to test if our outputs are correctly formatted.
